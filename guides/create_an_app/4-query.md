# 4. Query

## Retrieving from database

Every time, when refreshing your page, you lose the message history. This is not an ideal situation when you want to see what has been written. We have all these stored messages in our database and we want to retrieve them when someone logs in. Therefore, we will need to retrieve these messages and display them in the chat dialogue.

## Perform a callback `after_join`.
Go to the join function, and add the line just below `if authorized?(payload) do`

We are going to send a message contaning our `self` *PID(Process Identifier)* as the first parameter. The second parameter is a message to run a function called `after_join`. This function is identified by an atom type.
Add this line to function inside `lib/workshops_app_web/channels/general_channel.ex`

```elixir
  def join("random:lobby", payload, socket) do
    if authorized?(payload) do
      send(self(), :after_join) # <-- Add this line
      {:ok, socket}
    else
      {:error, %{reason: "unauthorized"}}
    end
  end
```

### What does send do?
`send` sends a message `:after_join`, with it's PID generated by the function `self()`. We want to be able to run that after join task asynchronously. Lets look at how we should receive the `:after_join` message.

## Receiving a message in a callback
We now know that a message identified by the atom `:after_join` is being sent. Phoenix provides us with a function called `handle_info` to be able to receive that message and do something with it. Insert the following code after the `join` function.

```elixir
  def handle_info(:after_join, socket) do
    messages =
      WorkshopsApp.Conversations.list_messages()
      |> Enum.map(fn(%{message: message, name: name}) -> %{message: message, name: name} end)
    push socket, "messages_history", %{messages: messages}
    {:noreply, socket}
  end
```

**Coach:** Please explain concept and above example of pattern matching.

**Coach:** Please explain `&` operator for function shorthand.

The only missing thing is `WorkshopsApp.Conversations.list_messages()` (we should get compilation error when function is called but not definied). To have everything working as expected, we need to add function, which will list all messages stored in our database. Let's open `WorkshopsApp.Conversations` module and put there:

```elixir
def list_messages do
  Repo.all(Message)
end

```

**Coach:** Please explain briefly what compilation is and what is the difference between compile-time and runtime.

**Coach:** Please say couple words about Repo and it's callbacks. 

## Retrieving all messages from our database
Phew, that looks like a lot is going on in the `handle_info` function. Let's break down the code to understand what is happening.

Thanks to `list_messages()` function we can retrieve all the messages from our database.

Then, we pipe the retrieved messages into a `map()` function provided by the `Enum` module. `map` applies this anonymous function onto every element in messages.

**Coach:** Please explain how `Enum.map` works, if it's unclear. This is also a very good time to play with other functions from `Enum` module.

## Passing the messages back to the browser
Finally, we want to push our list of messages to the socket via the push function.

We are using `push` instead of `broadcast`, because we only want to display it to the current user that has just joined the channel.

## Render the messages in the browser
Add the below code to the `assets/js/socket.js` file.

```javascript
    channel.on('messages_history', messages => {
      let messages_list = messages["messages"];

      messages_list.forEach( function(msg) {
        list.append(`<b>${msg["name"] || 'Anonymous'}:</b> ${msg["message"]}<br>`);
        list.prop({scrollTop: list.prop("scrollHeight")});
      });
    });
```

This is the final step, really. We need to display the messages in our browser by iterating through our list. You should have the history of messages displayed the moment you join the channel. Try opening multiple tabs connecting to http://localhost/4000.

You will be able to see that all the messages get rendered every time you join.

Based on: https://elixirgirls.com/guides/retrieve_message_history.html

After all these steps your code should look like this [Example app step 4 - query](https://github.com/Taste-Elixir/workshops-app/tree/4-query)